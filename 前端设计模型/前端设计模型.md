前端常用设计模式
========

前端常见的设计模式主要有以下几种：  
**1\. 单例模式**  
**2\. 工厂模式**  
**3\. 策略模式**  
**4\. 代理模式**  
**5\. 观察者模式**  
**6\. 模块模式**  
**7\. 构造函数模式**  
**8\. 混合模式**

*   单例模式  
    这种设计模式的思想是确保一个类只有唯一实例，一般用于全局缓存，比如全局window，唯一登录浮窗等。采用闭包的方式实现如下：
    var sig = (function() {
      let instance;
      function getInstance() {
        if(!this instanceOf Construct){
          instance = new Construct();
        }
        return instance;
      }
      function Construct() {

      }
      return {
        getInstance: getInstance
      }
    })()

```
    var single = (function(){
        let instance;
    
        function getInstance(){
    　　　　// 如果该实例存在，则直接返回，否则就对其实例化
            if( instance=== undefined ){
                instance= new Construct();
            }
            return instance;
        }
    
        function Construct(){
            // ... 生成单例的构造函数的代码
        }
    
        return {
            getInstance : getInstance
        }
    })();
```

*   工厂模式  
    工厂模式是创建对象的常用设计模式，为了不暴露创建对象的具体逻辑，将逻辑封装在一个函数中，这个函数就称为一个工厂。本质上是一个负责生产对象实例的工厂。工厂模式根据抽象程度的不同可以分为：简单工厂，工厂方法和抽象工厂。通常用于根据权限生成角色的场景，抽象工厂方法的实现如下：
```
    //安全模式创建的工厂方法函数
    let UserFactory = function(role) {
      if(this instanceof UserFactory) {
        var s = new this[role]();
        return s;
      } else {
        return new UserFactory(role);
      }
    }
    
    //工厂方法函数的原型中设置所有对象的构造函数
    UserFactory.prototype = {
      SuperAdmin: function() {
        this.name = "超级管理员",
        this.viewPage = ['首页', '通讯录', '发现页', '应用数据', '权限管理']
      },
      Admin: function() {
        this.name = "管理员",
        this.viewPage = ['首页', '通讯录', '发现页', '应用数据']
      },
      NormalUser: function() {
        this.name = '普通用户',
        this.viewPage = ['首页', '通讯录', '发现页']
      }
    }
    
    //调用
    let superAdmin = UserFactory('SuperAdmin');
    let admin = UserFactory('Admin') 
    let normalUser = UserFactory('NormalUser')
``` 

*   策略模式  
    策略模式的本意将算法的使用与算法的实现分离开来，避免多重判断调用哪些算法。适用于有多个判断分支的场景，如解决表单验证的问题。你可以创建一个validator对象，有一个validate()方法。这个方法被调用时不用区分具体的表单类型，它总是会返回同样的结果——一个没有通过验证的列表和错误信息。实现方式如下：
```
    // 对于vip客户
    function vipPrice() {
        this.discount = 0.5;
    }
     
    vipPrice.prototype.getPrice = function(price) {
    　　return price * this.discount;
    }
    // 对于老客户
    function oldPrice() {
        this.discount = 0.3;
    }
     
    oldPrice.prototype.getPrice = function(price) {
        return price * this.discount;
    }
    // 对于普通客户
    function Price() {
        this.discount = 1;
    }
     
    Price.prototype.getPrice = function(price) {
        return price ;
    }
    
    // 上下文，对于客户端的使用
    function Context() {
        this.name = '';
        this.strategy = null;
        this.price = 0;
    }
     
    Context.prototype.set = function(name, strategy, price) {
        this.name = name;
        this.strategy = strategy;
        this.price = price;
    }
    Context.prototype.getResult = function() {
        console.log(this.name + ' 的结账价为: ' + this.strategy.getPrice(this.price));
    }
    
    var context = new Context();
    var vip = new vipPrice();
    context.set ('vip客户', vip, 200);
    context.getResult();   // vip客户 的结账价为: 100
    
    var old = new oldPrice();
    context.set ('老客户', old, 200);
    context.getResult();  // 老客户 的结账价为: 60
    
    var Price = new Price();
    context.set ('普通客户', Price, 200);
    context.getResult();  // 普通客户 的结账价为: 200
```

*   代理模式  
    代理模式是为其他对象提供一种代理，也就是当其他对象直接访问该对象时，如果开销较大，就可以通过这个代理层控制对该对象的访问。常见的使用场景为懒加载，合并http请求和缓存。代理模式的实现如下：

    (function(){
        // 目标对象，是真正被代理的对象
        function Subject(){}
        Subject.prototype.request = function(){};
    
        function Proxy(realSubject){
            this.realSubject = realSubject;
        }
        Proxy.prototype.request = function(){
            this.realSubject.request();
        };
    }());
    

*   观察者模式  
    也叫发布订阅模式，在这种模式中，一个订阅者订阅发布者，当一个特定的事件发生的时候，发布者会通知（调用）所有的订阅者。实现代码如下：
```
    var EventCenter = (function(){
        var events = {};
        function on(event, handler){
            events[event] = events[event] || [];
            events[event].push({
                handler: handler
            });
        }
    
        function fire(event, args){
            if (!events[event]) {return}
            for (var i = 0; i < events[event].length; i++) {
                events[event][i].handler(args);
            }
        }
    
        function off(event){
            delete events[event];
        }
    
        return {
            on: on,
            fire: fire,
            off: off
        }
    })();
    
    EventCenter.on('event', function(data){
    console.log('event received...');
    });
```   

*   模块模式  
    模块模式可以指定类想暴露的属性和方法，并且不会污染全局。采用闭包的形式，实现如下：

    var Person = (function() {
        var name = 'xxx'
        function sayName() {
            console.log(name)
        }
        return{
            name: name,
            sayName: sayName
        }
    })()
    

*   构造函数模式和混合模式  
    构造函数和混合模式就是js中继承的两种实现方式，前者通过构造函数的形式定义类，通过new新增实例。而后者是将构造函数的引用属性和方法放到其原型上，子类是父类原型的一个实例。


关注

### 推荐阅读[更多精彩内容](/)

*   [js十大设计模式](/p/d35fd8aacb50)
    
    工厂模式类似于现实生活中的工厂可以产生大量相似的商品，去做同样的事情，实现同样的效果;这时候需要使用工厂模式。简单...
    
    [![](https://upload.jianshu.io/users/upload_avatars/4673327/af2fbd0b-e36c-4fd1-9914-61d924599954?imageMogr2/auto-orient/strip|imageView2/1/w/48/h/48/format/webp)舟渔行舟](/u/6e162b8f604e)阅读 6,392评论 2赞 17
    
*   [JS 设计模式](/p/efe14f993217)
    
    工厂模式 单体模式 模块模式 代理模式 职责链模式 命令模式 模板方法模式 策略模式 发布-订阅模式 中介者模式 ...
    
    [![](https://cdn2.jianshu.io/assets/default_avatar/15-a7ac401939dd4df837e3bbf82abaa2a8.jpg)HelloJames](/u/52ab36ffe732)阅读 690评论 0赞 6
    

*   [JS设计模式](/p/2a547be53034)
    
    设计模式 单例 单例模式的核心思想是让指定的类只存在唯一一个实例。这意味着当你第二次使用相同的类去创建对象的时候，...
    
    [![](https://cdn2.jianshu.io/assets/default_avatar/2-9636b13945b9ccf345bc98d0d81074eb.jpg)代码上的蚂蚁](/u/690a4d05a1d9)阅读 175评论 0赞 0
    
*   [javascript设计模式与开发实践](/p/74a004043f4c)
    
    javascript设计模式与开发实践 设计模式 每个设计模式我们需要从三点问题入手： 定义 作用 用法与实现 单...
    
    [![](https://cdn2.jianshu.io/assets/default_avatar/4-3397163ecdb3855a0a4139c34a695885.jpg)穿牛仔裤的蚊子](/u/8f5a24ad0051)阅读 1,672评论 0赞 11
    
    [![](//upload-images.jianshu.io/upload_images/5282870-25cee854ba02a329.png?imageMogr2/auto-orient/strip|imageView2/1/w/300/h/240/format/webp)](/p/74a004043f4c)
*   [五、面向对象的程序设计](/p/d801c77f4ebc)
    
      面向对象（Object-Oriented，OO）的语言有一个标志，那就是它们都有类的概念，而通过类可以创建任意...
    
    [![](https://cdn2.jianshu.io/assets/default_avatar/11-4d7c6ca89f439111aff57b23be1c73ba.jpg)霜天晓](/u/197fc03faee7)阅读 1,553评论 0赞 6
    
    [![](//upload-images.jianshu.io/upload_images/3500054-e8bc01ef7e4869fa.png?imageMogr2/auto-orient/strip|imageView2/1/w/300/h/240/format/webp)](/p/d801c77f4ebc)



在React中，数据在组件中是单向流动的，数据从一个方向父组件流向子组件（通过props）,所以，两个非父子组件之间通信就相对麻烦，redux的出现就是为了解决state里面的数据问题

2、Redux设计理念
-----------

Redux是将整个应用状态存储到一个地方上称为**store**,里面保存着一个状态树**store tree**,组件可以派发(dispatch)行为(action)给store,而不是直接通知其他组件，组件内部通过订阅**store**中的状态**state**来刷新自己的视图。

![](./Redux实现原理解析及应用 - 简书_files/6548744-df461a22f59ef7da.png)

redux-flow.png

3、Redux三大原则
-----------

*   1 唯一数据源
*   2 保持只读状态
*   3 数据改变只能通过纯函数来执行

### 1唯一数据源

> 整个应用的state都被存储到一个状态树里面，并且这个状态树，只存在于唯一的store中

### 2保持只读状态

> state是只读的，唯一改变state的方法就是触发action，action是一个用于描述以发生时间的普通对象

### 3数据改变只能通过纯函数来执行

> 使用纯函数来执行修改，为了描述action如何改变state的，你需要编写reducers

或许你读到这已经不知所云了，没事这只是让你了解一些redux到底是干嘛的，后面或详细的讲解各个部分的作用，并且会讲解redux实现原理

4、Redux概念解析
-----------

### 4.1 Store

*   store就是保存数据的地方，你可以把它看成一个数据，整个应用智能有一个store
*   Redux提供createStore这个函数，用来生成Store

    import {createStore} from 'redux'
    const store=createStore(fn);
    

### 4.2 State

state就是store里面存储的数据，store里面可以拥有多个state，Redux规定一个state对应一个View,只要state相同，view就是一样的，反过来也是一样的，可以通过**store.getState( )**获取

    import {createStore} from 'redux'
    const store=createStore(fn);
    const state=store.getState()
    

### 4.3 Action

state的改变会导致View的变化，但是在redux中不能直接操作state也就是说不能使用**this.setState**来操作，用户只能接触到View。在Redux中提供了一个对象来告诉Store需要改变state。Action是一个对象其中type属性是必须的，表示Action的名称，其他的可以根据需求自由设置。

    const action={
      type:'ADD_TODO',
      payload:'redux原理'
    }
    

在上面代码中，Action的名称是ADD_TODO，携带的数据是字符串‘redux原理’，Action描述当前发生的事情，这是改变state的唯一的方式

### 4.4 store.dispatch( )

store.dispatch( )是view发出Action的唯一办法

    store.dispatch({
      type:'ADD_TODO',
      payload:'redux原理'
    })
    

store.dispatch接收一个Action作为参数，将它发送给store通知store来改变state。

### 4.5 Reducer

Store收到Action以后，必须给出一个新的state，这样view才会发生变化。这种**state的计算过程**就叫做Reducer。  
Reducer是一个纯函数，他接收Action和当前state作为参数，返回一个新的state

> **注意：**Reducer必须是一个纯函数，也就是说函数返回的结果必须由参数state和action决定，而且不产生任何副作用也不能修改state和action对象

    const reducer =(state,action)=>{
      switch(action.type){
        case ADD_TODO:
            return newstate;
        default return state
      }
    }
    

5、Redux源码
---------

> 里面的注释就是我一步一步的分析，有点懒没有把代码拆分出来给你们看

    let createStore = (reducer) => {
        let state;
        //获取状态对象
        //存放所有的监听函数
        let listeners = [];
        let getState = () => state;
        //提供一个方法供外部调用派发action
        let dispath = (action) => {
            //调用管理员reducer得到新的state
            state = reducer(state, action);
            //执行所有的监听函数
            listeners.forEach((l) => l())
        }
        //订阅状态变化事件，当状态改变发生之后执行监听函数
        let subscribe = (listener) => {
            listeners.push(listener);
        }
        dispath();
        return {
            getState,
            dispath,
            subscribe
        }
    }
    let combineReducers=(renducers)=>{
        //传入一个renducers管理组，返回的是一个renducer
        return function(state={},action={}){
            let newState={};
            for(var attr in renducers){
                newState[attr]=renducers[attr](state[attr],action)
    
            }
            return newState;
        }
    }
    export {createStore,combineReducers};
    

6、Redux使用案例
-----------

html代码

    <div id="counter"></div>
      <button id="addBtn">+</button>
      <button id="minusBtn">-</button>
    

js代码

    function createStore(reducer) {
        var state;
        var listeners = [];
        var getState = () => state;
        var dispatch = (action) => {
            state = reducer(state, action);
            listeners.forEach(l=>l());
        }
        var subscribe = (listener) => {
            listeners.push(listener);
            return () => {
                listeners = listeners.filter((l) => l != listener)
            }
        }
        dispatch();
        return {
            getState, dispatch, subscribe
        }
    }
    var reducer = (state = 0, action) => {
        if (!action) return state;
        console.log(action);
        switch (action.type) {
            case 'INCREMENT':
                return state + 1;
            case 'DECREMENT':
                return state - 1;
            default:
                return state;
        }
    }
    var store = createStore(reducer);
    store.subscribe(function () {
        document.querySelector('#counter').innerHTML = store.getState();
    });
    
    document.querySelector('#addBtn').addEventListener('click', function () {
        store.dispatch({type: 'INCREMENT'});
    });
    document.querySelector('#minusBtn').addEventListener('click', function () {
        store.dispatch({type: 'DECREMENT'});
    });
    



